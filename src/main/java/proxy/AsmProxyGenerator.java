package proxy;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.HashMap;

import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;

import proxy.InvocationHandler;
import proxy.ProxyGenerator;

public class AsmProxyGenerator extends ProxyGenerator {
  // Automatically increments on every call of genearateProxyClass();
  protected static int classId = 0;

  // ClassLoader to load class from generated byte[].
  private static ProxyClassLoader classLoader = new ProxyClassLoader();

  @Override
  protected String proxyClassNamePrefix() {
    return "AsmProxyClass";
  }

  public Class<?> generateProxyClass(Class<?>[] interfaces) {
    ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);

    // Generate type names, note that all "." in class path are replaced by "/".
    //
    // Class name.
    String proxyClassName =
        ProxyGenerator.PACKAGE_NAME + "/" + proxyClassNamePrefix() + String.valueOf(classId++);
    // Interface names.
    String[] interfaceNames = new String[interfaces.length];
    for (int i = 0; i < interfaces.length; i++) {
      interfaceNames[i] = interfaces[i].getName().replace(".", "/");
    }

    // Create a new class.
    cw.visit(Opcodes.V1_8,  // java version: v1.8
             Opcodes.ACC_PUBLIC,  // access flags
             proxyClassName,  // class name
             null,  // signature
             "java/lang/Object",  // super class
             interfaceNames);  // interface names

    // Add field:
    //   private InvocationHandler handler;
    cw.visitField(Opcodes.ACC_PRIVATE,  // access flags
                  "handler",  // field name
                  Type.getDescriptor(InvocationHandler.class),  // field type
                  null,  // signature
                  null).visitEnd();  // default value
    // Add field:
    //   private java.util.HashMap<String, java.lang.reflect.Method> proxyMethods;
    cw.visitField(Opcodes.ACC_PRIVATE | Opcodes.ACC_STATIC ,  // access flags
                  "proxyMethods",  // field name
                  Type.getDescriptor(HashMap.class),  // field type
                  null,  // signature
                  null).visitEnd();  // default value

    // Add constructor.
    addConstructor(cw, proxyClassName);


    try {
      // Add method initMethodFields().
      addInitMethod(cw, proxyClassName, interfaces);

      // Add proxy methods.
      addProxyMethods(cw, proxyClassName, interfaces);
    } catch (NoSuchMethodException e) {
      e.printStackTrace();
      return null;
    }

    cw.visitEnd();
    byte[] data = cw.toByteArray();

    // Write class data to file.
    try {
      File file = new File("/usr/local/google/home/hangyuan/Desktop/Proxy.class");
      // File file = new File("/home/hy/Desktop/Proxy.class");
      FileOutputStream fout = new FileOutputStream(file);
      fout.write(data);
      fout.close();
    } catch (Exception e) {
      e.printStackTrace();
      return null;
    }

    Class<?> clazz = classLoader.defineClassForName(proxyClassName.replace("/", "."), data);
    return clazz;
  }

  // Constructor source code:
  //
  // public hyproxygen.ProxyClass(InvocationHandler handler) {
  //   this.handler = handler;
  //   this.proxyMethods = new java.util.HashMap<String, java.lang.reflect.Method>();
  //   this.initMethodFields();
  // }
  //
  // Byte code:
  //   0: aload_0
  //   1: invokespecial #1                  // Method java/lang/Object."<init>":()V
  //   4: aload_0
  //   5: aload_1
  //   6: putfield      #2                  // Field handler:Lproxy/InvocationHandler;
  //   9: aload_0
  //  10: new           #3                  // class java/util/HashMap
  //  13: dup
  //  14: invokespecial #4                  // Method java/util/HashMap."<init>":()V
  //  17: putfield      #5                  // Field proxyMethods:Ljava/util/HashMap;
  //  20: aload_0
  //  21: invokevirtual #6                  // Method initMethodFields:()V
  //  24: return
  //
  private boolean addConstructor(ClassWriter cw, String proxyClassName) {
    MethodVisitor constructor = cw.visitMethod(Opcodes.ACC_PUBLIC,
                                               "<init>",
                                               "(Lproxy/InvocationHandler;)V",
                                               null, null);
    constructor.visitVarInsn(Opcodes.ALOAD, 0);
    constructor.visitMethodInsn(Opcodes.INVOKESPECIAL,
                                "java/lang/Object",
                                "<init>",
                                "()V",
                                /* is interface = */false);
    
    // source: this.handler = handler;
    constructor.visitVarInsn(Opcodes.ALOAD, 0);
    constructor.visitVarInsn(Opcodes.ALOAD, 1);
    constructor.visitFieldInsn(Opcodes.PUTFIELD,
                               proxyClassName,
                               "handler",
                               Type.getDescriptor(InvocationHandler.class));

    constructor.visitInsn(Opcodes.RETURN);
    constructor.visitMaxs(0, 0);
    constructor.visitEnd();
    return true;
  }

  // This method creates class static block to initialize method map.
  private boolean addInitMethod(ClassWriter cw, String proxyClassName, Class<?>[] interfaces) 
      throws NoSuchMethodException {
    MethodVisitor mv = cw.visitMethod(Opcodes.ACC_STATIC,
                                      "<clinit>",
                                      "()V",
                                      null, null);

    // source: proxyMethods = new java.util.HashMap<String, java.lang.reflect.Method>();
    mv.visitTypeInsn(Opcodes.NEW, "java/util/HashMap");
    mv.visitInsn(Opcodes.DUP);
    mv.visitMethodInsn(Opcodes.INVOKESPECIAL,
                       "java/util/HashMap",
                       "<init>",
                       "()V",
                       /* is interface = */false);
    mv.visitFieldInsn(Opcodes.PUTSTATIC,
                      proxyClassName,
                      "proxyMethods",
                      Type.getDescriptor(java.util.HashMap.class));

    Label tryStart = new Label();
    mv.visitLabel(tryStart);

    Label nextIfc = new Label();
    for (int index = 0; index < interfaces.length; index++) {
      Class ifc = interfaces[index];

      if (index > 0) {
        mv.visitLabel(nextIfc);
        nextIfc = new Label();
      }

      // source: clazz = Class.forName("xx.xxx");
      mv.visitLdcInsn(ifc.getName());
      mv.visitMethodInsn(Opcodes.INVOKESTATIC,
                         "java/lang/Class",
                         "forName",
                         Type.getMethodDescriptor(Class.class.getMethod("forName",String.class)),
                         /* is interface = */false);
      mv.visitVarInsn(Opcodes.ASTORE, 0);  // var0 = clazz
      mv.visitVarInsn(Opcodes.ALOAD, 0);

      // source:
      //   for (java.lang.reflect.Method method : clazz.getMethods()) {
      //     proxyMethods.put(method.toString(), method);
      //   }
      mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                         "java/lang/Class",
                         "getMethods",
                         Type.getMethodDescriptor(Class.class.getMethod("getMethods")),
                         /* is interface = */false);
      mv.visitVarInsn(Opcodes.ASTORE, 1);  // var1 = methods = clazz.getMethods()

      mv.visitVarInsn(Opcodes.ALOAD, 1);
      mv.visitInsn(Opcodes.ARRAYLENGTH);
      mv.visitVarInsn(Opcodes.ISTORE, 2);  // var2 = methods.length
      mv.visitInsn(Opcodes.ICONST_0);
      mv.visitVarInsn(Opcodes.ISTORE, 3);  // var3 = i

      // Start for loop.
      Label forLoopStart = new Label();
      mv.visitLabel(forLoopStart);
      mv.visitVarInsn(Opcodes.ILOAD, 3);  // i
      mv.visitVarInsn(Opcodes.ILOAD, 2);  // methods.length
      mv.visitJumpInsn(Opcodes.IF_ICMPGE, nextIfc);  // if (i >= methods.length) break

      mv.visitVarInsn(Opcodes.ALOAD, 1);  // methods
      mv.visitVarInsn(Opcodes.ILOAD, 3);  // i
      mv.visitInsn(Opcodes.AALOAD);  // methods[i]
      mv.visitVarInsn(Opcodes.ASTORE, 4);  // var4 = method = methods[i]

      mv.visitFieldInsn(Opcodes.GETSTATIC,
                        proxyClassName,
                        "proxyMethods",
                        Type.getDescriptor(java.util.HashMap.class));  // this.proxyMethods

      mv.visitVarInsn(Opcodes.ALOAD, 4);
      mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                         "java/lang/reflect/Method",
                         "toString",
                         "()Ljava/lang/String;",
                         /* is interface = */false);  // method.toString()

      mv.visitVarInsn(Opcodes.ALOAD, 4);  /// method
      mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                         "java/util/HashMap",
                         "put",
                         "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;",
                         /* is interface = */false);  // proxyMethods.put(method.toString(), method)
      mv.visitInsn(Opcodes.POP);

      mv.visitIincInsn(3, 1);  // i++
      mv.visitJumpInsn(Opcodes.GOTO, forLoopStart);
    }

    Label tryEnd = new Label();
    mv.visitLabel(tryEnd);

    // Actually no more interface. Jump to return.
    mv.visitLabel(nextIfc);
    Label returnLabel = new Label();
    mv.visitJumpInsn(Opcodes.GOTO, returnLabel);

    // Handle exception.
    Label catchStart = new Label();
    mv.visitLabel(catchStart);

    mv.visitVarInsn(Opcodes.ASTORE, 1);  // var1 = catch (Exception e)
    mv.visitTypeInsn(Opcodes.NEW, "proxy/ClassNotFoundError");
    mv.visitInsn(Opcodes.DUP);
    mv.visitVarInsn(Opcodes.ALOAD, 1);
    mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                       "java/lang/ClassNotFoundException",
                       "getMessage",
                       "()Ljava/lang/String;",
                       /* is interface = */false);  // e.getMessage()
    mv.visitMethodInsn(Opcodes.INVOKESPECIAL,
                       "proxy/ClassNotFoundError",
                       "<init>",
                       "(Ljava/lang/String;)V",
                       /* is interface = */false);  // new ClassNotFoundError(e.getMessage())
    mv.visitInsn(Opcodes.ATHROW);  // throw

    mv.visitLabel(returnLabel);
    mv.visitInsn(Opcodes.RETURN);
    mv.visitTryCatchBlock(tryStart, tryEnd, catchStart, "java/lang/ClassNotFoundException");

    mv.visitMaxs(0, 0);  // Does not matter, COMPUTE_FRAMES is used.
    mv.visitEnd();

    return true;
  }

  private boolean addProxyMethods(ClassWriter cw, String proxyClassName, Class<?>[] interfaces)
      throws NoSuchMethodException {
    for (Class ifc : interfaces) {
      for (Method method : ifc.getMethods()) {
        addProxyMethodImpl(cw, proxyClassName, ifc, method);
      }
    }
    return true;
  }

  private boolean addProxyMethodImpl(
      ClassWriter cw, String proxyClassName, Class ifc, Method method) throws NoSuchMethodException{
    MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC,
                                      method.getName(),
                                      Type.getMethodDescriptor(method),
                                      null, null);

    mv.visitFieldInsn(Opcodes.GETSTATIC,
                      proxyClassName,
                      "proxyMethods",
                      Type.getDescriptor(java.util.HashMap.class));  // this.proxyMethods
    mv.visitLdcInsn(method.toString());   // methodName
    mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                       "java/util/HashMap",
                       "get",
                       Type.getMethodDescriptor(HashMap.class.getMethod("get", Object.class)),
                       /* is interface = */false);   // m = proxyMethods.get(methodName);
    mv.visitTypeInsn(Opcodes.CHECKCAST, "java/lang/reflect/Method");

    int numArgs = method.getParameterTypes().length;
    int localVarIndexForMethod = numArgs + 1;
    mv.visitVarInsn(Opcodes.ASTORE, localVarIndexForMethod);  // var? = m

    // Prepare for handler.invoke(this, m, args)
    mv.visitVarInsn(Opcodes.ALOAD, 0);  // push this
    mv.visitVarInsn(Opcodes.ALOAD, localVarIndexForMethod);  // push m
    mv.visitIntInsn(Opcodes.SIPUSH, numArgs);
    mv.visitTypeInsn(Opcodes.ANEWARRAY, "java/lang/Object");  // args = new Object[num_of_args];

    mv.visitInsn(Opcodes.DUP);
    for (int i = 0; i < numArgs; i++) {
      
    }

    return true;
  }

  private static class ProxyClassLoader extends ClassLoader {
    public ProxyClassLoader() {
      super(Thread.currentThread().getContextClassLoader());
    }
 
    public Class<?> defineClassForName(String name, byte[] data) {
      return this.defineClass(name, data, 0, data.length);
    }
  }
}
