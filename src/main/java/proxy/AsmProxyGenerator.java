package proxy;

import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.HashMap;

import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;

import proxy.InvocationHandler;
import proxy.ProxyGenerator;

// AsmProxyGenerator creates a proxy class by generating bytecode directly. See ExampleProxy.java
// as an example source code of the proxy class.
public class AsmProxyGenerator extends ProxyGenerator {
  // Automatically increments on every call of genearateProxyClass();
  protected static int classId = 0;

  // ClassLoader to load class from generated byte[].
  private static ProxyClassLoader classLoader = new ProxyClassLoader();

  @Override
  protected String proxyClassNamePrefix() {
    return "AsmProxyClass";
  }

  public Class<?> generateProxyClass(Class<?>[] interfaces) {
    ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);

    // Generate type names, note that all "." in class path are replaced by "/".
    //
    // Class name.
    String proxyClassName =
        ProxyGenerator.PACKAGE_NAME + "/" + proxyClassNamePrefix() + String.valueOf(classId++);
    // Interface names.
    String[] interfaceNames = new String[interfaces.length];
    for (int i = 0; i < interfaces.length; i++) {
      interfaceNames[i] = interfaces[i].getName().replace(".", "/");
    }

    // Create a new class.
    cw.visit(Opcodes.V1_8,  // java version: v1.8
             Opcodes.ACC_PUBLIC,  // access flags
             proxyClassName,  // class name
             null,  // signature
             "java/lang/Object",  // super class
             interfaceNames);  // interface names

    // Add field:
    //   private InvocationHandler handler;
    cw.visitField(Opcodes.ACC_PRIVATE,  // access flags
                  "handler",  // field name
                  Type.getDescriptor(InvocationHandler.class),  // field type
                  null,  // signature
                  null).visitEnd();  // default value
    // Add field:
    //   private java.util.HashMap<String, java.lang.reflect.Method> proxyMethods;
    cw.visitField(Opcodes.ACC_PRIVATE | Opcodes.ACC_STATIC ,  // access flags
                  "proxyMethods",  // field name
                  Type.getDescriptor(HashMap.class),  // field type
                  null,  // signature
                  null).visitEnd();  // default value

    // Add constructor.
    addConstructor(cw, proxyClassName);


    try {
      // Add method initMethodFields().
      addInitMethod(cw, proxyClassName, interfaces);

      // Add proxy methods.
      addProxyMethods(cw, proxyClassName, interfaces);
    } catch (NoSuchMethodException e) {
      e.printStackTrace();
      return null;
    }

    cw.visitEnd();
    byte[] data = cw.toByteArray();

    // Write class data to file.
    // try {
    //   File file = new File("/home/hy/Desktop/Proxy.class");
    //   FileOutputStream fout = new FileOutputStream(file);
    //   fout.write(data);
    //   fout.close();
    // } catch (Exception e) {
    //   e.printStackTrace();
    //   return null;
    // }

    Class<?> clazz = classLoader.defineClassForName(proxyClassName.replace("/", "."), data);
    return clazz;
  }

  // Constructor source code:
  //
  // public hyproxygen.ProxyClass(InvocationHandler handler) {
  //   this.handler = handler;
  // }
  //
  // Byte code:
  //   0: aload_0
  //   1: invokespecial #1                  // Method java/lang/Object."<init>":()V
  //   4: aload_0
  //   5: aload_1
  //   6: putfield      #2                  // Field handler:Lproxy/InvocationHandler;
  //   9: return
  //
  private boolean addConstructor(ClassWriter cw, String proxyClassName) {
    MethodVisitor constructor = cw.visitMethod(Opcodes.ACC_PUBLIC,
                                               "<init>",
                                               "(Lproxy/InvocationHandler;)V",
                                               null, null);
    constructor.visitVarInsn(Opcodes.ALOAD, 0);
    constructor.visitMethodInsn(Opcodes.INVOKESPECIAL,
                                "java/lang/Object",
                                "<init>",
                                "()V",
                                /* is interface = */false);
    
    // source: this.handler = handler;
    constructor.visitVarInsn(Opcodes.ALOAD, 0);
    constructor.visitVarInsn(Opcodes.ALOAD, 1);
    constructor.visitFieldInsn(Opcodes.PUTFIELD,
                               proxyClassName,
                               "handler",
                               Type.getDescriptor(InvocationHandler.class));

    constructor.visitInsn(Opcodes.RETURN);
    constructor.visitMaxs(0, 0);
    constructor.visitEnd();
    return true;
  }

  // This method creates class static block to initialize method map.
  private boolean addInitMethod(ClassWriter cw, String proxyClassName, Class<?>[] interfaces) 
      throws NoSuchMethodException {
    MethodVisitor mv = cw.visitMethod(Opcodes.ACC_STATIC,
                                      "<clinit>",
                                      "()V",
                                      null, null);

    // source: proxyMethods = new java.util.HashMap<String, java.lang.reflect.Method>();
    mv.visitTypeInsn(Opcodes.NEW, "java/util/HashMap");
    mv.visitInsn(Opcodes.DUP);
    mv.visitMethodInsn(Opcodes.INVOKESPECIAL,
                       "java/util/HashMap",
                       "<init>",
                       "()V",
                       /* is interface = */false);
    mv.visitFieldInsn(Opcodes.PUTSTATIC,
                      proxyClassName,
                      "proxyMethods",
                      Type.getDescriptor(java.util.HashMap.class));

    Label tryStart = new Label();
    mv.visitLabel(tryStart);

    Label nextIfc = new Label();
    for (int index = 0; index < interfaces.length; index++) {
      Class ifc = interfaces[index];

      if (index > 0) {
        mv.visitLabel(nextIfc);
        nextIfc = new Label();
      }

      // source: clazz = Class.forName("xx.xxx");
      mv.visitLdcInsn(ifc.getName());
      mv.visitMethodInsn(Opcodes.INVOKESTATIC,
                         "java/lang/Class",
                         "forName",
                         Type.getMethodDescriptor(Class.class.getMethod("forName",String.class)),
                         /* is interface = */false);
      mv.visitVarInsn(Opcodes.ASTORE, 0);  // var0 = clazz
      mv.visitVarInsn(Opcodes.ALOAD, 0);

      // source:
      //   for (java.lang.reflect.Method method : clazz.getMethods()) {
      //     proxyMethods.put(method.toString(), method);
      //   }
      mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                         "java/lang/Class",
                         "getMethods",
                         Type.getMethodDescriptor(Class.class.getMethod("getMethods")),
                         /* is interface = */false);
      mv.visitVarInsn(Opcodes.ASTORE, 1);  // var1 = methods = clazz.getMethods()

      mv.visitVarInsn(Opcodes.ALOAD, 1);
      mv.visitInsn(Opcodes.ARRAYLENGTH);
      mv.visitVarInsn(Opcodes.ISTORE, 2);  // var2 = methods.length
      mv.visitInsn(Opcodes.ICONST_0);
      mv.visitVarInsn(Opcodes.ISTORE, 3);  // var3 = i

      // Start for loop.
      Label forLoopStart = new Label();
      mv.visitLabel(forLoopStart);
      mv.visitVarInsn(Opcodes.ILOAD, 3);  // i
      mv.visitVarInsn(Opcodes.ILOAD, 2);  // methods.length
      mv.visitJumpInsn(Opcodes.IF_ICMPGE, nextIfc);  // if (i >= methods.length) break

      mv.visitVarInsn(Opcodes.ALOAD, 1);  // methods
      mv.visitVarInsn(Opcodes.ILOAD, 3);  // i
      mv.visitInsn(Opcodes.AALOAD);  // methods[i]
      mv.visitVarInsn(Opcodes.ASTORE, 4);  // var4 = method = methods[i]

      mv.visitFieldInsn(Opcodes.GETSTATIC,
                        proxyClassName,
                        "proxyMethods",
                        Type.getDescriptor(java.util.HashMap.class));  // this.proxyMethods

      mv.visitVarInsn(Opcodes.ALOAD, 4);
      mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                         "java/lang/reflect/Method",
                         "toString",
                         "()Ljava/lang/String;",
                         /* is interface = */false);  // method.toString()

      mv.visitVarInsn(Opcodes.ALOAD, 4);  /// method
      mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                         "java/util/HashMap",
                         "put",
                         "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;",
                         /* is interface = */false);  // proxyMethods.put(method.toString(), method)
      mv.visitInsn(Opcodes.POP);

      mv.visitIincInsn(3, 1);  // i++
      mv.visitJumpInsn(Opcodes.GOTO, forLoopStart);
    }

    Label tryEnd = new Label();
    mv.visitLabel(tryEnd);

    // Actually no more interface. Jump to return.
    mv.visitLabel(nextIfc);
    Label returnLabel = new Label();
    mv.visitJumpInsn(Opcodes.GOTO, returnLabel);

    // Handle exception.
    Label catchStart = new Label();
    mv.visitLabel(catchStart);

    mv.visitVarInsn(Opcodes.ASTORE, 1);  // var1 = catch (Exception e)
    mv.visitTypeInsn(Opcodes.NEW, "proxy/ClassNotFoundError");
    mv.visitInsn(Opcodes.DUP);
    mv.visitVarInsn(Opcodes.ALOAD, 1);
    mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                       "java/lang/ClassNotFoundException",
                       "getMessage",
                       "()Ljava/lang/String;",
                       /* is interface = */false);  // e.getMessage()
    mv.visitMethodInsn(Opcodes.INVOKESPECIAL,
                       "proxy/ClassNotFoundError",
                       "<init>",
                       "(Ljava/lang/String;)V",
                       /* is interface = */false);  // new ClassNotFoundError(e.getMessage())
    mv.visitInsn(Opcodes.ATHROW);  // throw

    mv.visitLabel(returnLabel);
    mv.visitInsn(Opcodes.RETURN);
    mv.visitTryCatchBlock(tryStart, tryEnd, catchStart, "java/lang/ClassNotFoundException");

    mv.visitMaxs(0, 0);  // Does not matter, COMPUTE_FRAMES is used.
    mv.visitEnd();

    return true;
  }

  private boolean addProxyMethods(ClassWriter cw, String proxyClassName, Class<?>[] interfaces)
      throws NoSuchMethodException {
    for (Class ifc : interfaces) {
      for (Method method : ifc.getMethods()) {
        addProxyMethodImpl(cw, proxyClassName, ifc, method);
      }
    }
    return true;
  }

  private boolean addProxyMethodImpl(
      ClassWriter cw, String proxyClassName, Class ifc, Method method) throws NoSuchMethodException{
    MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC,
                                      method.getName(),
                                      Type.getMethodDescriptor(method),
                                      null, null);

    mv.visitFieldInsn(Opcodes.GETSTATIC,
                      proxyClassName,
                      "proxyMethods",
                      Type.getDescriptor(java.util.HashMap.class));  // this.proxyMethods
    mv.visitLdcInsn(method.toString());   // methodName
    mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                       "java/util/HashMap",
                       "get",
                       Type.getMethodDescriptor(HashMap.class.getMethod("get", Object.class)),
                       /* is interface = */false);   // m = proxyMethods.get(methodName);
    mv.visitTypeInsn(Opcodes.CHECKCAST, "java/lang/reflect/Method");

    Class[] parameterTypes = method.getParameterTypes();
    int numArgs = parameterTypes.length;
    int localVarIndexForMethod = getArgsLength(parameterTypes) + 1;
    mv.visitVarInsn(Opcodes.ASTORE, localVarIndexForMethod);  // var? = m

    Label tryStart = new Label();
    mv.visitLabel(tryStart);

    // Prepare for handler.invoke(this, m, args)
    mv.visitVarInsn(Opcodes.ALOAD, 0);  // push handler
    mv.visitFieldInsn(Opcodes.GETFIELD,
                      proxyClassName,
                      "handler",
                      Type.getDescriptor(InvocationHandler.class));

    mv.visitVarInsn(Opcodes.ALOAD, 0);  // push this
    mv.visitVarInsn(Opcodes.ALOAD, localVarIndexForMethod);  // push m
    mv.visitIntInsn(Opcodes.SIPUSH, numArgs);
    mv.visitTypeInsn(Opcodes.ANEWARRAY, "java/lang/Object");  // args = new Object[num_of_args];

    // Push args into Object[]
    int localVarIndex = 1;
    for (int i = 0; i < numArgs; i++) {
      mv.visitInsn(Opcodes.DUP);
      mv.visitIntInsn(Opcodes.SIPUSH, i);

      Class paramClass = parameterTypes[i];
      localVarIndex = castParameterType(mv, paramClass, localVarIndex);
      mv.visitInsn(Opcodes.AASTORE);  // methods[i]
    }

    mv.visitMethodInsn(
        Opcodes.INVOKEINTERFACE,
        "proxy/InvocationHandler",
        "invoke",
        "(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;",
        /* is interface = */true);   // handler.invoke(this, m, args);

    int localVarIndexForResult = localVarIndexForMethod + 1;
    mv.visitVarInsn(Opcodes.ASTORE, localVarIndexForResult);  // re = handler.invoke(this, m, args);

    Label tryEnd = new Label();
    castReturnType(mv, method.getReturnType(), localVarIndexForResult, tryEnd);

    Label catchStart = new Label();
    mv.visitLabel(catchStart);

    // Handle exception
    mv.visitVarInsn(Opcodes.ASTORE, localVarIndexForResult);  // var1 = catch (Exception e)
    mv.visitTypeInsn(Opcodes.NEW, "proxy/MethodInvocationError");
    mv.visitInsn(Opcodes.DUP);
    mv.visitVarInsn(Opcodes.ALOAD, localVarIndexForResult);
    mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                       "java/lang/Exception",
                       "getMessage",
                       "()Ljava/lang/String;",
                       /* is interface = */false);  // e.getMessage()
    mv.visitMethodInsn(Opcodes.INVOKESPECIAL,
                       "proxy/MethodInvocationError",
                       "<init>",
                       "(Ljava/lang/String;)V",
                       /* is interface = */false);  // new ClassNotFoundError(e.getMessage())
    mv.visitInsn(Opcodes.ATHROW);  // throw

    mv.visitTryCatchBlock(tryStart, tryEnd, catchStart, "java/lang/Exception");

    mv.visitMaxs(0, 0);  // Does not matter, COMPUTE_FRAMES is used.
    mv.visitEnd();

    return true;
  }

  // Get the total length of args in local variable space. Note long and double types take one
  // additional slot.
  private int getArgsLength(Class[] parameterTypes) {
    int length = parameterTypes.length;
    for (Class type : parameterTypes) {
      String typeStr = type.getName();
      if (typeStr.equals("long") || typeStr.equals("double")) {
        length++;
      }
    }
    return length;
  }

  private int castParameterType(MethodVisitor mv, Class<?> paramClass, int localVarIndex)
      throws NoSuchMethodException {
    if (paramClass.getName().equals("int")) {
      mv.visitVarInsn(Opcodes.ILOAD, localVarIndex);
      mv.visitMethodInsn(Opcodes.INVOKESTATIC,
                         "java/lang/Integer",
                         "valueOf",
                         Type.getMethodDescriptor(Integer.class.getMethod("valueOf", int.class)),
                         /* is interface = */false);
      return localVarIndex + 1;
    } else if (paramClass.getName().equals("short")) {
      mv.visitVarInsn(Opcodes.ILOAD, localVarIndex);
      mv.visitMethodInsn(Opcodes.INVOKESTATIC,
                         "java/lang/Short",
                         "valueOf",
                         Type.getMethodDescriptor(Short.class.getMethod("valueOf", short.class)),
                         /* is interface = */false);
      return localVarIndex + 1;
    } else if (paramClass.getName().equals("long")) {
      mv.visitVarInsn(Opcodes.LLOAD, localVarIndex);
      mv.visitMethodInsn(Opcodes.INVOKESTATIC,
                         "java/lang/Long",
                         "valueOf",
                         Type.getMethodDescriptor(Long.class.getMethod("valueOf", long.class)),
                         /* is interface = */false);
      return localVarIndex + 2;
    } else if (paramClass.getName().equals("float")) {
      mv.visitVarInsn(Opcodes.FLOAD, localVarIndex);
      mv.visitMethodInsn(Opcodes.INVOKESTATIC,
                         "java/lang/Float",
                         "valueOf",
                         Type.getMethodDescriptor(Float.class.getMethod("valueOf", float.class)),
                         /* is interface = */false);
      return localVarIndex + 1;
    } else if (paramClass.getName().equals("double")) {
      mv.visitVarInsn(Opcodes.DLOAD, localVarIndex);
      mv.visitMethodInsn(Opcodes.INVOKESTATIC,
                         "java/lang/Double",
                         "valueOf",
                         Type.getMethodDescriptor(
                            Double.class.getMethod("valueOf", double.class)),
                         /* is interface = */false);
      return localVarIndex + 2;
    } else if (paramClass.getName().equals("byte")) {
      mv.visitVarInsn(Opcodes.ILOAD, localVarIndex);
      mv.visitMethodInsn(Opcodes.INVOKESTATIC,
                         "java/lang/Byte",
                         "valueOf",
                         Type.getMethodDescriptor(Byte.class.getMethod("valueOf",byte.class)),
                         /* is interface = */false);
      return localVarIndex + 1;
    } else if (paramClass.getName().equals("char")) {
      mv.visitVarInsn(Opcodes.ILOAD, localVarIndex);
      mv.visitMethodInsn(Opcodes.INVOKESTATIC,
                         "java/lang/Character",
                         "valueOf",
                         Type.getMethodDescriptor(
                            Character.class.getMethod("valueOf",char.class)),
                         /* is interface = */false);
      return localVarIndex + 1;
    } else if (paramClass.getName().equals("boolean")) {
      mv.visitVarInsn(Opcodes.ILOAD, localVarIndex);
      mv.visitMethodInsn(Opcodes.INVOKESTATIC,
                         "java/lang/Boolean",
                         "valueOf",
                         Type.getMethodDescriptor(
                            Boolean.class.getMethod("valueOf",boolean.class)),
                         /* is interface = */false);
      return localVarIndex + 1;
    } else {
      mv.visitVarInsn(Opcodes.ALOAD, 1);
      return localVarIndex + 1;
    }
  }

  private void castReturnType(
      MethodVisitor mv, Class<?> returnType, int localVarIndexForResult, Label tryEnd) {
    if (returnType.getName().equals("void")) {
      // If original method return value if void, just call return instead of areturn.
      mv.visitLabel(tryEnd);
      mv.visitInsn(Opcodes.RETURN);
    } else {
      mv.visitVarInsn(Opcodes.ALOAD, localVarIndexForResult);  // re

      String typeName = returnType.getName();
      if (typeName.equals("int")) {
        mv.visitTypeInsn(Opcodes.CHECKCAST, "java/lang/Integer");
        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                           "java/lang/Integer",
                           "intValue",
                           "()I",
                           /* is interface = */false);  // e.getMessage()
        mv.visitLabel(tryEnd);
        mv.visitInsn(Opcodes.IRETURN);
      } else if (typeName.equals("short")) {
        mv.visitTypeInsn(Opcodes.CHECKCAST, "java/lang/Short");
        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                           "java/lang/Short",
                           "shortValue",
                           "()S",
                           /* is interface = */false);  // e.getMessage()
        mv.visitLabel(tryEnd);
        mv.visitInsn(Opcodes.IRETURN);
      } else if (typeName.equals("long")) {
        mv.visitTypeInsn(Opcodes.CHECKCAST, "java/lang/Long");
        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                           "java/lang/Long",
                           "longValue",
                           "()J",
                           /* is interface = */false);  // e.getMessage()
        mv.visitLabel(tryEnd);
        mv.visitInsn(Opcodes.LRETURN);
      } else if (typeName.equals("float")) {
        mv.visitTypeInsn(Opcodes.CHECKCAST, "java/lang/Float");
        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                           "java/lang/Float",
                           "floatValue",
                           "()F",
                           /* is interface = */false);  // e.getMessage()
        mv.visitLabel(tryEnd);
        mv.visitInsn(Opcodes.FRETURN);
      } else if (typeName.equals("double")) {
        mv.visitTypeInsn(Opcodes.CHECKCAST, "java/lang/Double");
        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                           "java/lang/Double",
                           "doubleValue",
                           "()D",
                           /* is interface = */false);  // e.getMessage()
        mv.visitLabel(tryEnd);
        mv.visitInsn(Opcodes.DRETURN);
      } else if (typeName.equals("byte")) {
        mv.visitTypeInsn(Opcodes.CHECKCAST, "java/lang/Byte");
        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                           "java/lang/Byte",
                           "byteValue",
                           "()B",
                           /* is interface = */false);  // e.getMessage()
        mv.visitLabel(tryEnd);
        mv.visitInsn(Opcodes.IRETURN);
      } else if (typeName.equals("char")) {
        mv.visitTypeInsn(Opcodes.CHECKCAST, "java/lang/Character");
        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                           "java/lang/Character",
                           "charValue",
                           "()C",
                           /* is interface = */false);  // e.getMessage()
        mv.visitLabel(tryEnd);
        mv.visitInsn(Opcodes.IRETURN);
      } else if (typeName.equals("boolean")) {
        mv.visitTypeInsn(Opcodes.CHECKCAST, "java/lang/Boolean");
        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                           "java/lang/Boolean",
                           "booleanValue",
                           "()Z",
                           /* is interface = */false);  // e.getMessage()
        mv.visitLabel(tryEnd);
        mv.visitInsn(Opcodes.IRETURN);
      }else {
        mv.visitTypeInsn(Opcodes.CHECKCAST, Type.getInternalName(returnType));
        mv.visitLabel(tryEnd);
        mv.visitInsn(Opcodes.ARETURN);
      }
    }
  }

  private static class ProxyClassLoader extends ClassLoader {
    public ProxyClassLoader() {
      super(Thread.currentThread().getContextClassLoader());
    }
 
    public Class<?> defineClassForName(String name, byte[] data) {
      return this.defineClass(name, data, 0, data.length);
    }
  }
}
